# <center>排序算法-考研数据结构<center/>
<摘要>所谓排序，即将原本无序的序列重新排列成有序序列的过程。这个序列中的每一项可能是单独的数据元素，也可能是一条记录（记录是由多个数据元素组成的，如一个学生记录就是由学号、姓名、年龄、专业等数据元素组成的）。如果是记录，则既可以按照记录的主关键字排序（主关键字唯一标识一条记录，如学生记录中的学号就是主关键字，学号不能重复，用来唯一标识一个学生），也可以按照记录的次关键字排序（如学生记录中的姓名、专业等都是次关键字，次关键字是可以重复的）。<!--more-->
&emsp;&emsp;而稳定性是指当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的。例如，某序列有两个关键字都是50，以50（a）和50（b）来区分它们，用某种算法A对其排序，排序前50（a）在50（b）之前，如果排序后50（a）仍然在50（b）之前，则A是稳定的；如果能找出一种情况，使排序后50（a）在50（b）之后，则A是不稳定的。如果关键字不能重复，则排序结果是唯一的，那么选择的排序算法稳定与否就无关紧要；如果关键字可以重复，则在选择排序算法时，就要根据具体的需求采考虑选择稳定的还是不稳定的排序算法。
### 各排序算法的时间复杂度与空间复杂度及稳定性比较

![排序算法的时间复杂度与空间复杂度及稳定性比较](O.png "时间和空间复杂度及稳定性总结")
----
### 1、直接插入
>算法思想：每趟将一个待排序的关键字按照其值的大小插入到已经排好的部分有序序列的适当位置上，
>直到所有待排关键字都被插入到有序序列中为止。
~~~C++
void InsertSort(int R[], int n) {
	int i, j;
	int temp;
	for (i = 1; i < n; i++) {
		temp = R[i];  //将待插入关键字暂存在temp中
		j = i - 1;
		/*下面这个循环完成了从待排关键字之前的关键字开始扫描，如果大于待排关键字，则后移一位*/
		while (j >= 0 && temp < R[j]) {
			R[j + 1] = R[j];
			j--;
		}
		R[j + 1] = temp;   //找到插入位置，将temp中暂存的待排关键字插入
	}
	//对排序了的数组输出
	outPutArr(R, n);
}
~~~
<br><br>
### 2、希尔排序
>算法思想：希尔排序又称之为缩小增量排序，其本质还是插入排序，
>只不过是将待排序列按照某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。
>这个规则的体现就是增量的选取，希尔排序的时间复杂度为：&emsp;O(n*logn)。

~~~C++
void shellSort(int R[], int n){
	int temp;
	for(int gap = n/2; gap > 0; gap /= 2){
		for(int i = gap; i < n; i++){
			temp = R[i];
			int j;
			for(j = i; j >= gap && R[j-gap] > temp; j -= gap){
				R[j] = R[j-gap];
			}
			R[j] = temp;
		}
	}
	outPutArr(R,n);
}
~~~
<br><br>
### 3、冒泡排序
>算法思想：假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，
>若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为一.趟冒泡，
>结果将最小的元素交换到待排序列的第一一个位置（关键字最小的元素如气泡一般逐渐
>往上“漂浮”直至“水面”，这就是冒泡排序名字的由来）。下一趟冒泡时，前一趟确定的
>最小元素不再参与比较，待排序列减少-一个元素，每趟冒泡的结果把序列中的最小元素
>放到了序列的最终位置，.....  这样最多做n-1趟冒泡就能把所有元素排好序。

~~~C++
void bubbleSort(int R[], int n){
	int i,j;
	bool flag;
	int temp;
	for(i = n-1; i > 0; i--){
		flag = false;        //flag用来标记此趟排序是否发生了交换
		for(j = 1; j <= i; j++){
			if(R[j-1] > R[j]){
				temp = R[j];
				R[j] = R[j-1];
				R[j-1] = temp;
				flag = true;  //如果没发生交换，则flag为0
			}
		}
		if(!flag){      //一趟排序过程中没有发生排序，则证明剩余序列有序，不在冒泡
			outPutArr(R,n);
			return;
		}
	}
}
~~~
<br><br>
## 4、快速排序
>算法思想：也是交换类的排序，它通过多次划分操作实现排序。以升序为例，
>其执行流程可以概括为：每一趟选择当前所有子序列中的一个关键字（通常是第一个）作为枢轴，
>将子序列中比枢轴小的移到枢轴的前边，比枢轴大的移动到枢轴的后边；
>当本趟所有的子序列都被枢轴以上述规则划分完毕后会的到新的一组更短的子序列，
>它们成为下一趟划分的初始序列集。快速排序的算法思想基于分治思想的，
>其平均时间复杂度为O(n*logn)，最坏时间复杂度为O(n^2)。
~~~C++
void quickSort(int R[], int low, int high){
	int temp;
	int i = low, j = high;
	if(low < high){
		temp = R[low];
		while(i < j){   //将数组中小于temp的放在左边，大于temp的放在右边
			while(j > i && R[j] >= temp){   //从右往左扫描，找到一个小于temp的关键字
				j--;
			}
			if(i < j){
				R[i] = R[j];         //放在temp左边
				i++;                 //右移一位
			}
			while(i < j && R[i] < temp){    //从左往右扫描，找到一个大于temp的关键字
				i++;
			}
			if(i < j){
				R[j] = R[i];        //放在temp右边
				j--;                //左移一位
			}
		}
		R[i] = temp;                //将temp放在最终位置
		quickSort(R,low,i-1);       //递归的对temp左边的关键字排序
		quickSort(R,i+1,high);      //递归的对temp右边的关键字排序
	}
}
~~~
<br><br>
### 5、简单选择排序
>算法思想：选择类排序的主要动作是“选择”。简单选择采用最简单的选择方式，从头至尾扫描序列，
>选出最小的一个关键字，和第一个关键字交换，接着从剩下的关键字中继续这种选择和交换，
>最终使序列有序。
~~~C++
void selectSort(int R[], int n){
	int i, j, k;
	int temp;
	for(i = 0; i < n; i++){
		k = i;
		/*下面这个循环是算法的关键，它从无序序列中挑出一个最小的关键字*/
		for(j = i + 1; j < n; j++){
			if(R[k] > R[j]){
				k = j;
			}
		}
		/*下面这三句完成最小关键字与无序序列第一个关键字的交换*/
		temp = R[i];
		R[i] = R[k];
		R[k] = temp;
	}
	outPutArr(R,n);
}
~~~
<br><br>
### 6、堆排序
>算法思想：堆是一种完全二叉树,这颗二叉树满足：任何一个非叶结点的值都不大于(或小于)其左右
>孩子结点的值。若父亲大孩子小，这样的堆称之为大顶堆；若父亲小孩子大称为小根堆。根据堆的
>定义可以知道，代表堆的这颗完全二叉树的根结点是最大的（或者最小的），因此将一个无序的序列
>调整为一个堆，就可以找到这个序列的最大值（或者最小）的值，然后将找出的值交换到这个序列的
>最后（或最前），这样有序序列关键字增加1个，无序序列中的关键字减少1个，对新的无序序列重复
>这样的操作，就实现了排序。
~~~C++
/**
堆排序算法主方法
*/
void heapSort(int R[], int n){
	int i;
	int temp;
	for(i = n/2 - 1; i >= 0; i--){      //建立初始堆
		sift(R, i, n-1);
	}
	for(i = n-1; i > 0; i--){        //进行n-1次循环，完成堆排序
		temp = R[0];             //一下3句换出根节点的关键字，将其放入最终位置
		R[0] = R[i];
		R[i] = temp;
		sift(R, 0, i-1);           //在减少了一个关键字的无序序列中调整
	}
	outPutArr(R, n);
}


/**
堆的局部调整方法
*/
void sift(int R[] ,int low, int high){      //关键字设定下表从0开始
	int i = low,j = 2*i + 1;                 //R[j]是R[i]的左孩子节点
	int temp = R[i];
	while(j <= high){
		if(j < high && R[j] < R[j+1]){         //若右孩子较大，则j指向右孩子
			j++;                           //j变为2*i+2
		}
		if(temp < R[j]){
			R[i] = R[j];                  //将R[j]调整到双亲节点的位置
			i = j;                        //修改i和j的值，继续向下调整
			j = 2*i + 1;
		}else{
			break;                       //调整结束
		}
	}
	R[i] = temp;                         //被调整节点放入最终位置
}
~~~
<br><br>
### 7、归并排序
>算法思想：二路归并排序是采用的分而治之的思想。将一个待排序的序列分成两个序列，
>分别对这两个序列排序。而对于这两个序列排序的方式也是和之前一样，将这两个序列分别分成两个
>序列分别排序。一直这样分割下去，知道序列中没有元素或者只有一个元素为止。因为没有元素的序列
>和只有一个元素的序列定是一个有序的序列，所以相当于将这个序列排序完毕，向上返回。
>返回的过程中做的最重要的一件事就是将两个有序的序列合并成一个有序的序列。所以归并排序
>最重要的两步是分割和合并。
~~~C++
/**归并排序主方法*/
void mergeSort(int R[], int low, int high){
	if(low < high){
		int mid = (low + high) / 2;
		mergeSort(R, low, mid);       //归并排序前半段
		mergeSort(R, mid+1, high);    //归并排序后半段
		merge(R, low, mid, high);    //将R数组中low~mid,mid~high两段序列归并为一个序列
	}
}


/**将两个序列归并为一个有序序列*/
void merge(int R[], int low, int mid, int high){
	int i, j, k;
	int n1 = mid - low + 1;
	int n2 = high - mid;
	int left[n1], right[n2];    //此处在C++和C里会有编译错误，解决办法是将测试用例的逻辑结构改为一般线性表或者用Java语言实现该算法
	for(i = 0; i < n1; i++){
		left[i] = R[low + i];
	}
	for(j = 0; j < n2; j++){
		right[j] = R[mid + 1 + j];
	}
	i = 0; j = 0; k = low;
	while(i < n1 && j < n2){
		if(left[i] <= right[j]){
			R[k] = left[i++];
		}else{
			R[k] = right[j++];
		}
		k++;
	}
	while(i<n1){
		R[k++] = left[i++];
	}
	while(j<n2){
		R[k++] = right[j++];
	}
}
~~~